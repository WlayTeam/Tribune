<!DOCTYPE html><body><table><tr><td>http://www.importnew.com/22092.html</td><td>我与IDEA的不舍情缘</td><td>
原文出处： 张龙
JetBrains这家来自于捷克的公司是一家真正伟大的公司，它向全球的广大开发者提供了诸多的生产力工具，让我们这些以编程为生的程序员们能够真正享受到编程的乐趣。JetBrains的产品线十分丰富，从大名鼎鼎的IntelliJ IDEA、PyCharm、PhpStorm、WebStorm、RubyMine到移动开发利器AppCode，再到今年初正式发布的数据库管理一站式工具DataGrip，以及团队协同开发工具YouTrack、TeamCity等等，每一个产品都在各自的领域中傲视群雄，当仁不让。

此前得知CSDN与JetBrains公司合作举办了『JetBrains远征赛之使用技能征集』活动，同时CSDN编辑也邀请我为活动写一些文章，由于自己使用JetBrains公司的各种产品已经有很多年了，期间也积累了不少的经验和使用感受，同时也写过不少关于JetBrains公司产品的文章，便欣然接受了邀请，于是才有了下面这些文字。由于标题字数有限制，因此标题只写了IDEA这一工具，不过本文将会介绍IntelliJ IDEA、WebStorm与DataGrip这3个分别面向Java、前端与数据库的工具；他们也是我在日常开发工作中频繁使用的工具。
工作近10年来，我目前主要从事系统架构设计工作，每天的主要工作内容是规划系统设计方案、优化系统、核心模块代码的编写以及指导团队成员。可以这么说，我每天的绝大部分时间都是在编写代码，因此一款趁手的IDE就显得尤为重要了。现在，我每天游走在Java、Python、Angular、React、Node、iOS与Android之间；这每一项技术都需要有相应的工具作为支撑，值得一提的是，这其中我所使用的大部分IDE都来自于JetBrains，下面是我Mac Dock栏上的JetBrains公司部分工具图标一览：

在我的积极推动下，现在项目组所有成员也都从原来所使用的各种工具转向了JetBrains产品。由于一直在做Java开发，因此就从Java IDE IntelliJ IDEA开始说起吧。
IntelliJ IDEA——Java开发者所需的唯一工具

与很多Java开发者一样，我从2007年研究生毕业后进入到公司从事Java相关开发后就一直在使用Eclipse工具栈（包括MyEclipse）进行Java系统的开发工作，这种情况一直持续到2012年；期间也积累了丰富的Eclipse使用经验，同时感受到Eclipse的强大以及插件体系的精妙之处。不得不说，Eclipse是一款伟大的产品，免费、使用人数众多，上手比较轻松，我相信这也是很多Eclipse使用者的直观感受。
随着Maven的日渐流行，我们的项目开始转向Maven进行依赖与项目生命周期的管理。当我使用Eclipse与Maven进行集成时，我感受到了深深的挫败感；在2012年那个时候，Maven已然成为了Java构建事实上的标准，然而遗憾的是，Eclipse与Maven的集成做的非常差劲，通过Maven插件导入Maven项目后需要进行大量的手工设置，这些设置非常容易出错，相信当时很多人都遇到了和我一样的境况（因为当时通过Google搜索Eclipse与Maven集成会看到大量的文章，都是为了解决集成方式先天不足这一问题）。这些本来应该由IDE帮助我们完成的事情却转嫁给了开发者，显然这不是我想要的结果。经过不断尝试后，虽然成功完成了Eclipse与Maven的集成，但中间的操作步骤却异常繁琐，而且还要注意先后顺序，团队的每一名成员都需要按照这个步骤来才能顺利完成集成工作；新人加入团队后也要重复这一过程。当时我就在想，有没有其他IDE能够比Eclipse在这方面做的更好呢？于是，我想到了IntelliJ IDEA。当时，Java领域知名的三大IDE分别是：Eclipse、IntelliJIDEA与NetBeans（相信现在也是这个局面）。由于个人不是太喜欢NetBeans，于是就下载了IntelliJ IDEA试用。安装完毕后发现IDEA已经集成了Maven功能，于是通过Git将仓库中的Maven项目导入进来，待系统刷新完毕后令我惊讶的一幕发生了：IDEA已经自动识别出了这是个Maven项目，并且完成了一切的设置工作；可我什么都没做啊，IDE已经自动帮助我完成了全部的设置工作，接下来我要做的就是编码——程序员的主要工作。这简直太令我震惊了，在Eclipse中需要花费那么久才能搞定的事情，使用IDEA竟然短短几十秒就由工具帮助我全部自动完成了。激动之余我开始了对IntelliJ IDEA的尝试与探索。
不得不说的是，由于具备了多年的Eclipse使用经验，因此对于Eclipse的各项功能与操作方式都了然于心了，特别是Eclipse的界面风格。但一开始使用IDEA时感受到了极度的不适应（后来在与很多新人沟通IDEA使用情况时发现，这几乎是每个IDEA新手的共同感受，看来习惯的力量是巨大的），菜单项、命令方式、操作方式、特别是快捷键（实际上，IDEA提供了Eclipse风格快捷键，可以在首选项的键盘设置中进行配置）都存在着巨大的差别，这其中界面风格的差别尤为突出。IDEA的界面与Eclipse是完全不同的（我们不能说哪一个更好，其实更多的是习惯造成的），这一点对于新手来说是比较难以克服的。据我所知，有不少IDEA新手在使用IDEA不到一天的时间后就放弃了，究其原因还是难以逾越习惯的心魔。好在自己对于新事物的适应能力比较强，经过了一周左右的不断尝试后，终于降伏了IDEA这一庞大的工具。使用得越多越能感受到IDEA的强大与贴心。
实际上，IDEA也提供了非常强大的插件体系，用于补充和完善IDE自身的功能。而且，IDEA现有的插件已经非常丰富了，比如说用于git .ignore文件处理的.ignore、用于thrift接口定义文件编写的Thrift Support、用于编写markdown文档的Markdown support、用于编写FreeMarker模板文件的FreeMarker support，以及用于在IDEA中模拟VI操作的IdeaVim等等。除此之外，IDEA自身就已经通过插件的方式提供了对诸多框架与语言的支持，比如说spring、hibernate、Struts2、Nodejs、Scala、单元测试、React、Bash、CoffeeScript、YAML、Gradle、GitHub等等。凭借着自身强大的功能与完善的插件体系，IntelliJ IDEA为开发者提供了开箱即用的便利性，这对于开发者效能的提升是显而易见的。

提起IntelliJ IDEA，就不得不提到它的快捷键。IDEA的快捷键之多、之方便为广大开发者津津乐道。众所周知，开发者在进行开发工作时，双手尽量不要离开键盘，因为从键盘切换到鼠标然后再回到键盘这看似不经意的动作，实际上每天做多了就会对效率造成一定的影响；IDEA凭借强大的快捷键与Alt+Enter功能（无论何时，这个快捷键都会给你与当前上下文相关的智能提示，这是个极具价值的功能）能极大提升开发者的生产率（当然了，前提是需要花一些时间熟悉IDEA的常用快捷键，这样才会事半功倍）。
目前项目的后端使用Gradle进行构建，使用git进行版本控制与管理，使用的技术栈有Spring、Spring MVC、MyBatis、Thrift、Kafka等，IDEA同样对其提供了完备的支持。开发者无需离开IDEA就可以完成几乎全部的日常开发工作，IDEA提供的Terminal（Mac下）支持也是非常有益的，这样就无需在IDEA与Terminal之间频繁切换了。
另外，值得称道的是IDEA对于Java8 Lambda表达式与调试的强大支持。众所周知，调试是我们日常开发中必不可少的一环，IDEA在这方面给予了我们最大的支持，当程序暂停在断点处时，编辑器会直接在界面上显示出当前上下文环境下所有变量的值，这对于开发者对程序执行流程的理解上无疑是帮助巨大的。

从图中可以看到，断点处的变量值直接就显示在了变量旁边，这一特性能有效提升调试的效率。
WebStorm——前端开发者的福音

目前的前端领域呈现出百花齐放、百家争鸣的景象，各种技术、框架、思想与库层出不穷。几年前还是用jQuery打天下的时代已经离我们渐行渐远。目前比较流行的方式是前后端分离，即前端通过Angular或是React等框架完成，后端则提供Rest接口供前端调用，前端使用Node与后端的Rest接口通信。这种做法的优势很明显。首先，前后端分离可以让前端开发者与后端开发者各施其职，互不影响。只需提前定义好通信的接口（HTTP+JSON），前后端开发者即可各自进行开发，不会因为后端某个功能没有完成而影响前端的开发（前端可以通过Mock的方式构造接口数据）；同样，后端只需关注接口的正确性即可，因为所有功能都已经服务化了。另外一个优势在于，采用了前后端分离的方式进行开发，前端开发者就再也不必使用后端开发者使用的IDE工具了（在之前传统的类JSP开发模式下，前端开发者必须要先搭建好后端的开发环境才能顺利进行开发，然而这显然会造成前端效能的低下，毕竟前后端代码耦合到了一起是非常不利于开发和阅读的，虽然Velocity和FreeMarker等模板语言能够在一定程度上缓解这个问题，但还是无法从根本上解决）。正所谓一个硬币有两面一样，前后端分离也存在着一定的弊端，最为明显的就是对前端开发者的技能要求会更高，项目开始的开发成本会更高，中间增加了Node这一环节，会导致出现问题时解决起来变得更加困难。但总的来看，前后端分离是未来的发展趋势，也是我们应该深刻理解的思想。
JetBrains公司的WebStorm是一款专门针对前端的开发工具套件，它提供了大量的优秀特性来提升前端开发者的生产力。对于HTML、CSS及JavaScript的支持非常棒，代码提示、代码补全、格式化等功能一应俱全；此外，WebStorm还通过内建插件的形式对当今流行的前端开发框架与库提供了极其完备的支持，如Angular、React、CoffeeScript、Meteor、Yeoman、Nodejs等等，这些优秀的特性让前端开发者可以将精力放在重要的开发上，而非繁复的代码工程。

目前，公司的前端开发工具已经全部转至WebStorm，前端开发人员也对这款强大的IDE赞不绝口，极大提升了生产力。
DataGrip——数据库与SQL领域的瑞士军刀

DataGrip是JetBrains公司今年初才发布的一款数据库管理工具，它号称数据库与SQL领域中的瑞士军刀。值得一提的是，DataGrip的前身叫做0xDBE，在DataGrip发布前已经发布一年多了，我也在很早的时候就申请了0xDBE的试用资格，一路见证了0xDBE的不断发展壮大。与JetBrains产品线上的其他产品类似，DataGrip也提供了Windows、Linux与Mac版本。此外，JetBrains的其他产品如IntelliJ IDEA等也都通过插件的方式集成了DataGrip，这使得开发者能够更加方便地操作数据库。DataGrip支持几乎所有主流的关系数据库产品，如DB2、Derby、H2、MySQL、Oracle、PostgreSQL、SQL Server、Sqllite及Sybase等，并且提供了简单易用的界面，开发者上手几乎不会遇到任何困难。面对市场上已有的诸多老牌数据库管理工具（如MySQL WorkBench、Toad、NaviCat、phpMyAdmin、SequelPro、SQLWave等等），DataGrip要想获得用户青睐一定得有自己的看家本领才行。实践证明，DataGrip不辱使命，在众多同类产品中脱颖而出，迅速赢得了市场。我也在长时间使用DataGrip的过程中领悟到了JetBrains的软件设计哲学——易用且强大。
DataGrip的主要特性有：
提供了对主流数据库管理系统的访问

市场上的重量级产品：Oracle、SQL Server、DB2与Sybase
社区流行产品：MySQL、PostgreSQL
小众产品：SQLite、Apache Derby、HyperSQL与H2

修改数据库对象并自动生成脚本
DataGrip提供了一个UI用以执行诸如创建/修改表、管理列、键与索引的操作。可以立即执行生成的代码，也可以在文本编辑器中打开，并直接操作DDL脚本。DataGrip提供了上下文感知的代码完成特性，能够帮助你更快地编写SQL代码。代码完成可以感知到表结构、外键，甚至是正在编辑的代码中所创建的数据库对象。DataGrip可以检测到代码中潜在的Bug，并即时提供最佳的修复建议。它能够立刻让你知道无法解析的对象，并且总能提供问题的修复建议。

高效编写SQL并消除重复的编码工作
借助于DataGrip，你可以通过代码完成特性更快地编写代码。只需输入数据库对象、标识符或是变量的名字即可，DataGrip会提供一个匹配的列表。DataGrip能够感知到完成JOIN从句所需的依赖，并提供函数与过程所需的参数类型，还可以给出INSERT语句的表结构。DataGrip提供了Live Templates用以生成语句的常见部分，你可以使用默认值，也可以创建新值。

在代码间导航并在输入时进行重命名
DataGrip能够解析出SQL文件中的对象引用。如果对变量或是别名进行了重命名，那么所有用到他们的地方都会相应地进行重命名。如果在SQL中重命名了数据库对象，实际的数据库中也会进行重命名。DataGrip能够正确解析出SQL代码中所有的引用，并帮助你对其进行重构。
IDE会展示出对象（表、列等等）的使用，还会在专门的视图中展示出变量。导航工具可以帮助你在编辑器、模式视图等各种上下文中选择对象。

处理数据并探索关系
你可以通过强大的表编辑器添加、删除、以及克隆数据行。通过过滤文本域可以只查看所需的数据，而无需编写WHERE字句。寻找所需数据的另一种方式是使用文本搜索。如果不知道哪一列包含了你所要寻找的数据，那么文本搜索就是一项非常有用的功能了。可以在文本搜索中使用正则表达式。通过外键数据导航可以转到当前行所引用的数据，反之亦然。

分析查询与比较结果
在单击Execute按钮时可以选择让DataGrip做什么事情——执行子查询、执行外部查询，或是执行整个脚本。只想执行特定的一部分代码？只需将其选中并执行即可。DataGrip还提供了执行计划，其结果集类似于表编辑器，包含了相同的选项，如添加/删除行、文本搜索与数据导航等。可以在diff查看器中比较两个结果集。

DataGrip基于IntelliJ Platform，带来了：

拥有多种光标与语法感知选择的文本编辑器
版本控制系统集成：Git、Subversion、Mercurial等等
插件生态圈：Terminal、Textmate等等

不得不说的Android Studio——Android开发一站式解决方案
最后，不得不提的还有Android Studio——Google官方推荐的Android开发工具。

众所周知，过去Android的主要开发工具是ADT（Android Development Toolkit）,它是基于Eclipse之上的一整套面向Android开发的插件集合，提供了Android开发的各种工具与调试器及模拟器等。不过，在去年底，Google宣布将停止对Eclipse Android开发工具的一切支持，转而将Android Studio作为官方推荐的开发工具。Android Studio是基于IntelliJ平台的，充分利用了既有的基础设施。对于那些熟悉IntelliJ IDEA平台的开发者来说，上手Android Studio是非常轻松的事情，这也是现在大部分公司进行Android开发所使用的工具。
总结
JetBrains是一家伟大的公司，它所推出的诸多工具面向软件开发的各个领域，从Java、.NET、PHP、Python、Ruby到iOS、版本控制、持续集成以及数据库管理，极大提升了软件开发者的效率。
作为一名开发者，我非常感谢JetBrains让世界变得如此美好，让我们的开发工作变得更加有趣，也让我深刻认识到——优秀的工具是多么的重要。
谢谢你，JetBrains！


</td></tr><tr><td>http://www.importnew.com/21807.html</td><td>AOP 那点事儿</td><td>
原文出处： 黄勇
又是一个周末，刚给宝宝喂完牛奶，终于让她睡着了。所以现在我才能腾出手来，坐在电脑面前给大家写这篇文章。
今天我要和大家分享的是 AOP（Aspect-Oriented Programming）这个东西，名字与 OOP 仅差一个字母，其实它是对 OOP 编程方式的一种补充，并非是取而代之。翻译过来就是“面向方面编程”，可我更倾向于翻译为“面向切面编程”。它听起有些的神秘，为什么呢？当你看完这篇文章的时候，就会知道，我们做的很重要的工作就是去写这个“切面” 。那么什么是“切面”呢？
没错！就是用一把刀来切一坨面。注意，相对于面而言，我们一定是横着来切它，这简称为“横切”。可以把一段代码想象成一坨面，同样也可以用一把刀来横切它，下面要做的就是如何去实现这把刀！
需要澄清的是，这个概念不是由 Rod Johnson（老罗）提出的。其实很早以前就有了，目前最知名最强大的 Java 开源项目就是 AspectJ 了，然而它的前身是 AspectWerkz（该项目已经在 2005 年停止更新），这才是 AOP 的老祖宗。老罗（一个头发秃得和我老爸有一拼的天才）写了一个叫做 Spring 框架，从此一炮走红，成为了 Spring 之父。他在自己的 IOC 的基础之上，又实现了一套 AOP 的框架，后来仿佛发现自己越来越走进深渊里，在不能自拔的时候，有人建议他还是集成 AspectJ 吧，他在万般无奈之下才接受了该建议。于是，我们现在用得最多的想必就是 Spring + AspectJ 这种 AOP 框架了。
那么 AOP 到底是什么？如何去使用它？本文将逐步带您进入 AOP 的世界，让您感受到前所未有的畅快！
不过在开始讲解 AOP 之前，我想有必要回忆一下这段代码：
1. 写死代码
先来一个接口：
public interface Greeting {

    void sayHello(String name);
}
还有一个实现类：
public class GreetingImpl implements Greeting {

    @Override
    public void sayHello(String name) {
        before();
        System.out.println("Hello! " + name);
        after();
    }

    private void before() {
        System.out.println("Before");
    }

    private void after() {
        System.out.println("After");
    }
}
before() 与 after() 方法写死在 sayHello() 方法体中了，这样的代码的味道非常不好。如果哪位仁兄大量写了这样的代码，肯定要被你的架构师骂个够呛。
比如：我们要统计每个方法的执行时间，以对性能作出评估，那是不是要在每个方法的一头一尾都做点手脚呢？
再比如：我们要写一个 JDBC 程序，那是不是也要在方法的开头去连接数据库，方法的末尾去关闭数据库连接呢？
这样的代码只会把程序员累死，把架构师气死！
一定要想办法对上面的代码进行重构，首先给出三个解决方案：
2. 静态代理
最简单的解决方案就是使用静态代理模式了，我们单独为 GreetingImpl 这个类写一个代理类：
public class GreetingProxy implements Greeting {

    private GreetingImpl greetingImpl;

    public GreetingProxy(GreetingImpl greetingImpl) {
        this.greetingImpl = greetingImpl;
    }

    @Override
    public void sayHello(String name) {
        before();
        greetingImpl.sayHello(name);
        after();
    }

    private void before() {
        System.out.println("Before");
    }

    private void after() {
        System.out.println("After");
    }
}
就用这个 GreetingProxy 去代理 GreetingImpl，下面看看客户端如何来调用：
public class Client {

    public static void main(String[] args) {
        Greeting greetingProxy = new GreetingProxy(new GreetingImpl());
        greetingProxy.sayHello("Jack");
    }
}
这样写没错，但是有个问题，XxxProxy 这样的类会越来越多，如何才能将这些代理类尽可能减少呢？最好只有一个代理类。
这时我们就需要使用 JDK 提供的动态代理了。
3. JDK 动态代理
public class JDKDynamicProxy implements InvocationHandler {

    private Object target;

    public JDKDynamicProxy(Object target) {
        this.target = target;
    }

    @SuppressWarnings("unchecked")
    public <T> T getProxy() {
        return (T) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            this
        );
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object result = method.invoke(target, args);
        after();
        return result;
    }

    private void before() {
        System.out.println("Before");
    }

    private void after() {
        System.out.println("After");
    }
}
客户端是这样调用的：
public class Client {

    public static void main(String[] args) {
        Greeting greeting = new JDKDynamicProxy(new GreetingImpl()).getProxy();
        greeting.sayHello("Jack");
    }
}
这样所有的代理类都合并到动态代理类中了，但这样做仍然存在一个问题：JDK 给我们提供的动态代理只能代理接口，而不能代理没有接口的类。有什么方法可以解决呢？
4. CGLib 动态代理
我们使用开源的 CGLib 类库可以代理没有接口的类，这样就弥补了 JDK 的不足。CGLib 动态代理类是这样玩的：
public class CGLibDynamicProxy implements MethodInterceptor {

    private static CGLibDynamicProxy instance = new CGLibDynamicProxy();

    private CGLibDynamicProxy() {
    }

    public static CGLibDynamicProxy getInstance() {
        return instance;
    }

    @SuppressWarnings("unchecked")
    public <T> T getProxy(Class<T> cls) {
        return (T) Enhancer.create(cls, this);
    }

    @Override
    public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        before();
        Object result = proxy.invokeSuper(target, args);
        after();
        return result;
    }

    private void before() {
        System.out.println("Before");
    }

    private void after() {
        System.out.println("After");
    }
}
以上代码中了 Singleton 模式，那么客户端调用也更加轻松了：
public class Client {

    public static void main(String[] args) {
        Greeting greeting = CGLibDynamicProxy.getInstance().getProxy(GreetingImpl.class);
        greeting.sayHello("Jack");
    }
}
到此为止，我们能做的都做了，问题似乎全部都解决了。但事情总不会那么完美，而我们一定要追求完美！
老罗搞出了一个 AOP 框架，能否做到完美而优雅呢？请大家继续往下看吧！
5. Spring AOP：前置增强、后置增强、环绕增强（编程式）
在 Spring AOP 的世界里，与 AOP 相关的术语实在太多，往往也是我们的“拦路虎”，不管是看那本书或是技术文档，在开头都要将这些术语逐个灌输给读者。我想这完全是在吓唬人了，其实没那么复杂的，大家放轻松一点。
我们上面例子中提到的 before() 方法，在 Spring AOP 里就叫 Before Advice（前置增强）。有些人将 Advice 直译为“通知”，我想这是不太合适的，因为它根本就没有“通知”的含义，而是对原有代码功能的一种“增强”。再说，CGLib 中也有一个 Enhancer 类，它就是一个增强类。
此外，像 after() 这样的方法就叫 After Advice（后置增强），因为它放在后面来增强代码的功能。
如果能把 before() 与 after() 合并在一起，那就叫 Around Advice（环绕增强），就像汉堡一样，中间夹一根火腿。
这三个概念是不是轻松地理解了呢？如果是，那就继续吧！
我们下面要做的就是去实现这些所谓的“增强类”，让他们横切到代码中，而不是将这些写死在代码中。
先来一个前置增强类吧：
public class GreetingBeforeAdvice implements MethodBeforeAdvice {

    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println("Before");
    }
}
注意：这个类实现了 org.springframework.aop.MethodBeforeAdvice 接口，我们将需要增强的代码放入其中。
再来一个后置增强类吧：
public class GreetingAfterAdvice implements AfterReturningAdvice {

    @Override
    public void afterReturning(Object result, Method method, Object[] args, Object target) throws Throwable {
        System.out.println("After");
    }
}
类似地，这个类实现了 org.springframework.aop.AfterReturningAdvice 接口。
最后用一个客户端来把它们集成起来，看看如何调用吧：
public class Client {

    public static void main(String[] args) {
        ProxyFactory proxyFactory = new ProxyFactory();     // 创建代理工厂
        proxyFactory.setTarget(new GreetingImpl());         // 射入目标类对象
        proxyFactory.addAdvice(new GreetingBeforeAdvice()); // 添加前置增强
        proxyFactory.addAdvice(new GreetingAfterAdvice());  // 添加后置增强 

        Greeting greeting = (Greeting) proxyFactory.getProxy(); // 从代理工厂中获取代理
        greeting.sayHello("Jack");                              // 调用代理的方法
    }
}
请仔细阅读以上代码及其注释，您会发现，其实 Spring AOP 还是挺简单的，对吗？
当然，我们完全可以只定义一个增强类，让它同时实现 MethodBeforeAdvice 与 AfterReturningAdvice 这两个接口，如下：
public class GreetingBeforeAndAfterAdvice implements MethodBeforeAdvice, AfterReturningAdvice {

    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println("Before");
    }

    @Override
    public void afterReturning(Object result, Method method, Object[] args, Object target) throws Throwable {
        System.out.println("After");
    }
}
这样我们只需要使用一行代码，同时就可以添加前置与后置增强：
proxyFactory.addAdvice(new GreetingBeforeAndAfterAdvice());
刚才有提到“环绕增强”，其实这个东西可以把“前置增强”与“后置增强”的功能给合并起来，无需让我们同时实现以上两个接口。
public class GreetingAroundAdvice implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        before();
        Object result = invocation.proceed();
        after();
        return result;
    }

    private void before() {
        System.out.println("Before");
    }

    private void after() {
        System.out.println("After");
    }
}
环绕增强类需要实现 org.aopalliance.intercept.MethodInterceptor 接口。注意，这个接口不是 Spring 提供的，它是 AOP 联盟（一个很牛逼的联盟）写的，Spring 只是借用了它。
在客户端中同样也需要将该增强类的对象添加到代理工厂中：
proxyFactory.addAdvice(new GreetingAroundAdvice());
好了，这就是 Spring AOP 的基本用法，但这只是“编程式”而已。Spring AOP 如果只是这样，那就太傻逼了，它曾经也是一度宣传用 Spring 配置文件的方式来定义 Bean 对象，把代码中的 new 操作全部解脱出来。
6.   Spring AOP：前置增强、后置增强、环绕增强（声明式）
先看 Spring 配置文件是如何写的吧：
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans

http://www.springframework.org/schema/beans/spring-beans.xsd


http://www.springframework.org/schema/context


http://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 扫描指定包（将 @Component 注解的类自动定义为 Spring Bean） -->
    <context:component-scan base-package="aop.demo"/>

    <!-- 配置一个代理 -->
    <bean id="greetingProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="interfaces" value="aop.Greeting"/> <!-- 需要代理的接口 -->
        <property name="target" ref="greetingImpl"/>       <!-- 接口实现类 -->
        <property name="interceptorNames">                 <!-- 拦截器名称（也就是增强类名称，Spring Bean 的 id） -->
            <list>
                <value>greetingAroundAdvice</value>
            </list>
        </property>
    </bean>

</beans>
一定要阅读以上代码的注释，其实使用 ProxyFactoryBean 就可以取代前面的 ProxyFactory，其实它们俩就一回事儿。我认为 interceptorNames 应该改名为 adviceNames 或许会更容易让人理解，不就是往这个属性里面添加增强类吗？
此外，如果只有一个增强类，可以使用以下方法来简化：
...

    <bean id="greetingProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="interfaces" value="aop.Greeting"/>
        <property name="target" ref="greetingImpl"/>
        <property name="interceptorNames" value="greetingAroundAdvice"/> <!-- 注意这行配置 -->
    </bean>

...
还需要注意的是，这里使用了 Spring 2.5+ 的特性“Bean 扫描”，这样我们就无需在 Spring 配置文件里不断地定义 <bean id=”xxx”/> 了，从而解脱了我们的双手。
看看这是有多么的简单：
@Component
public class GreetingImpl implements Greeting {

    ...
}
@Component
public class GreetingAroundAdvice implements MethodInterceptor {

    ...
}
最后看看客户端吧：
public class Client {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("aop/demo/spring.xml"); // 获取 Spring Context
        Greeting greeting = (Greeting) context.getBean("greetingProxy");                        // 从 Context 中根据 id 获取 Bean 对象（其实就是一个代理）
        greeting.sayHello("Jack");                                                              // 调用代理的方法
    }
}
代码量确实少了，我们将配置性的代码放入配置文件，这样也有助于后期维护。更重要的是，代码只关注于业务逻辑，而将配置放入文件中。这是一条最佳实践！
除了上面提到的那三类增强以外，其实还有两类增强也需要了解一下，关键的时候您要能想得到它们才行。
7. Spring AOP：抛出增强
程序报错，抛出异常了，一般的做法是打印到控制台或日志文件中，这样很多地方都得去处理，有没有一个一劳永逸的方法呢？那就是 Throws Advice（抛出增强），它确实很强，不信你就继续往下看：
@Component
public class GreetingImpl implements Greeting {

    @Override
    public void sayHello(String name) {
        System.out.println("Hello! " + name);

        throw new RuntimeException("Error"); // 故意抛出一个异常，看看异常信息能否被拦截到
    }
}
下面是抛出增强类的代码：
@Component
public class GreetingThrowAdvice implements ThrowsAdvice {

    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {
        System.out.println("---------- Throw Exception ----------");
        System.out.println("Target Class: " + target.getClass().getName());
        System.out.println("Method Name: " + method.getName());
        System.out.println("Exception Message: " + e.getMessage());
        System.out.println("-------------------------------------");
    }
}
抛出增强类需要实现 org.springframework.aop.ThrowsAdvice 接口，在接口方法中可获取方法、参数、目标对象、异常对象等信息。我们可以把这些信息统一写入到日志中，当然也可以持久化到数据库中。
这个功能确实太棒了！但还有一个更厉害的增强。如果某个类实现了 A 接口，但没有实现 B 接口，那么该类可以调用 B 接口的方法吗？如果您没有看到下面的内容，一定不敢相信原来这是可行的！
8. Spring AOP：引入增强
以上提到的都是对方法的增强，那能否对类进行增强呢？用 AOP 的行话来讲，对方法的增强叫做 Weaving（织入），而对类的增强叫做 Introduction（引入）。而 Introduction Advice（引入增强）就是对类的功能增强，它也是 Spring AOP 提供的最后一种增强。建议您一开始千万不要去看《Spring Reference》，否则您一定会后悔的。因为当您看了以下的代码示例后，一定会彻底明白什么才是引入增强。
定义了一个新接口 Apology（道歉）：
public interface Apology {

    void saySorry(String name);
}
但我不想在代码中让 GreetingImpl 直接去实现这个接口，我想在程序运行的时候动态地实现它。因为假如我实现了这个接口，那么我就一定要改写 GreetingImpl 这个类，关键是我不想改它，或许在真实场景中，这个类有1万行代码，我实在是不敢动了。于是，我需要借助 Spring 的引入增强。这个有点意思了！
@Component
public class GreetingIntroAdvice extends DelegatingIntroductionInterceptor implements Apology {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        return super.invoke(invocation);
    }

    @Override
    public void saySorry(String name) {
        System.out.println("Sorry! " + name);
    }
}
以上定义了一个引入增强类，扩展了 org.springframework.aop.support.DelegatingIntroductionInterceptor 类，同时也实现了新定义的 Apology 接口。在类中首先覆盖了父类的 invoke() 方法，然后实现了 Apology 接口的方法。我就是想用这个增强类去丰富 GreetingImpl 类的功能，那么这个 GreetingImpl 类无需直接实现 Apology 接口，就可以在程序运行的时候调用 Apology 接口的方法了。这简直是太神奇的！
看看是如何配置的吧：
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans

http://www.springframework.org/schema/beans/spring-beans.xsd


http://www.springframework.org/schema/context


http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="aop.demo"/>

    <bean id="greetingProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="interfaces" value="aop.demo.Apology"/>          <!-- 需要动态实现的接口 -->
        <property name="target" ref="greetingImpl"/>                    <!-- 目标类 -->
        <property name="interceptorNames" value="greetingIntroAdvice"/> <!-- 引入增强 -->
        <property name="proxyTargetClass" value="true"/>                <!-- 代理目标类（默认为 false，代理接口） -->
    </bean>

</beans>
需要注意 proxyTargetClass 属性，它表明是否代理目标类，默认为 false，也就是代理接口了，此时 Spring 就用 JDK 动态代理。如果为 true，那么 Spring 就用 CGLib 动态代理。这简直就是太方便了！Spring 封装了这一切，让程序员不在关心那么多的细节。我们要向老罗同志致敬，您是我们心中永远的 idol！
当您看完下面的客户端代码，一定会完全明白以上的这一切：
public class Client {

    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("aop/demo/spring.xml");
        GreetingImpl greetingImpl = (GreetingImpl) context.getBean("greetingProxy"); // 注意：转型为目标类，而并非它的 Greeting 接口
        greetingImpl.sayHello("Jack");

        Apology apology = (Apology) greetingImpl; // 将目标类强制向上转型为 Apology 接口（这是引入增强给我们带来的特性，也就是“接口动态实现”功能）
        apology.saySorry("Jack");
    }
}
没想到 saySorry() 方法原来是可以被 greetingImpl 对象来直接调用的，只需将其强制转换为该接口即可。
我们再次感谢 Spring AOP，感谢老罗给我们提供了这么强大的特性！
其实，Spring AOP 还有很多精彩的地方，下一篇将介绍更多更有价值的 AOP 技术，让大家得到更多的收获。
未完，待续…
AOP 那点儿事（续集）
源码下载


</td></tr><tr><td>http://www.importnew.com/17886.html</td><td>跟我学Spring3（6.7）： 通知顺序</td><td>
原文出处： 张开涛
如果我们有多个通知想要在同一连接点执行，那执行顺序如何确定呢？Spring AOP使用AspectJ的优先级规则来确定通知执行顺序。总共有两种情况：同一切面中通知执行顺序、不同切面中的通知执行顺序。
首先让我们看下
1） 同一切面中通知执行顺序：如图6-6所示。

图6-6 同一切面中的通知执行顺序
而如果在同一切面中定义两个相同类型通知（如同是前置通知或环绕通知（proceed之前））并在同一连接点执行时，其执行顺序是未知的，如果确实需要指定执行顺序需要将通知重构到两个切面，然后定义切面的执行顺序。
java代码：
错误“Advice precedence circularity error”：说明AspectJ无法决定通知的执行顺序，只要将通知方法分类并按照顺序排列即可解决。
2）不同切面中的通知执行顺序：当定义在不同切面的相同类型的通知需要在同一个连接点执行，如果没指定切面的执行顺序，这两个通知的执行顺序将是未知的。
如果需要他们顺序执行，可以通过指定切面的优先级来控制通知的执行顺序。
Spring中可以通过在切面实现类上实现org.springframework.core.Ordered接口或使用Order注解来指定切面优先级。在多个切面中，Ordered.getValue()方法返回值（或者注解值）较小值的那个切面拥有较高优先级，如图6-7所示。

图6-7 两个切面指定了优先级对于@AspectJ风格和注解风格可分别用以下形式指定优先级：</td></tr><tr><td>http://www.importnew.com/17755.html</td><td>跟我学Spring3（6.1）：AOP的HelloWorld</td><td>
原文出处： 张开涛
6.2.1 准备环境
首先准备开发需要的jar包，请到spring-framework-3.0.5.RELEASE-dependencies.zip和spring-framework-3.0.5.RELEASE-with-docs中查找如下jar包：
org.springframework.aop-3.0.5.RELEASE.jar
com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar
com.springsource.org.aopalliance-1.0.0.jar
com.springsource.net.sf.cglib-2.2.0.jar
将这些jar包添加到“Build Path”下。
6.2.2 定义目标类
1）定义目标接口：
java代码：
package cn.javass.spring.chapter6.service; 
public interface IHelloWorldService { 
 public void sayHello(); 
}
2）定义目标接口实现：
java代码：
package cn.javass.spring.chapter6.service.impl; 
import cn.javass.spring.chapter6.service.IHelloWorldService; 
public class HelloWorldService implements IHelloWorldService { 
 @Override 
 public void sayHello() { 
 System.out.println("============Hello World!"); 
 } 
}
注：在日常开发中最后将业务逻辑定义在一个专门的service包下，而实现定义在service包下的impl包中，服务接口以IXXXService形式，而服务实现就是XXXService，这就是规约设计，见名知义。当然可以使用公司内部更好的形式，只要大家都好理解就可以了。
6.2.2 定义切面支持类
有了目标类，该定义切面了，切面就是通知和切入点的组合，而切面是通过配置方式定义的，因此这定义切面前，我们需要定义切面支持类，切面支持类提供了通知实现：
java代码：
package cn.javass.spring.chapter6.aop; 
public class HelloWorldAspect { 
 //前置通知 
 public void beforeAdvice() { 
 System.out.println("===========before advice"); 
} 
//后置最终通知 
 public void afterFinallyAdvice() { 
 System.out.println("===========after finally advice"); 
 } 
}
此处HelloWorldAspect类不是真正的切面实现，只是定义了通知实现的类，在此我们可以把它看作就是缺少了切入点的切面。
注：对于AOP相关类最后专门放到一个包下，如“aop”包，因为AOP是动态织入的，所以如果某个目标类被AOP拦截了并应用了通知，可能很难发现这个通知实现在哪个包里，因此推荐使用规约命名，方便以后维护人员查找相应的AOP实现。
6.2.3 在XML中进行配置
有了通知实现，那就让我们来配置切面吧：
1）首先配置AOP需要aop命名空间，配置头如下：
java代码：
<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 xmlns:aop="http://www.springframework.org/schema/aop" 
 xsi:schemaLocation=" 

http://www.springframework.org/schema/beans


http://www.springframework.org/schema/beans/spring-beans-3.0.xsd


http://www.springframework.org/schema/aop


http://www.springframework.org/schema/aop/spring-aop-3.0.xsd">

</beans>
 2）配置目标类：
java代码：
<bean id="helloWorldService" 
class="cn.javass.spring.chapter6.service.impl.HelloWorldService"/>
 3）配置切面：
java代码：
<bean id="aspect" class="cn.javass.spring.chapter6.aop.HelloWorldAspect"/> 
<aop:config> 
<aop:pointcut id="pointcut" expression="execution(* cn.javass..*.*(..))"/> 
 <aop:aspect ref="aspect"> 
 <aop:before pointcut-ref="pointcut" method="beforeAdvice"/> 
 <aop:after pointcut="execution(* cn.javass..*.*(..))" method="afterFinallyAdvice"/> 
 </aop:aspect> 
</aop:config>
切入点使用<aop:config>标签下的<aop:pointcut>配置，expression属性用于定义切入点模式，默认是AspectJ语法，“execution(* cn.javass..*.*(..))”表示匹配cn.javass包及子包下的任何方法执行。
切面使用<aop:config>标签下的<aop:aspect>标签配置，其中“ref”用来引用切面支持类的方法。
前置通知使用<aop:aspect>标签下的<aop:before>标签来定义，pointcut-ref属性用于引用切入点Bean，而method用来引用切面通知实现类中的方法，该方法就是通知实现，即在目标类方法执行之前调用的方法。
最终通知使用<aop:aspect>标签下的<aop:after >标签来定义，切入点除了使用pointcut-ref属性来引用已经存在的切入点，也可以使用pointcut属性来定义，如pointcut=”execution(* cn.javass..*.*(..))”，method属性同样是指定通知实现，即在目标类方法执行之后调用的方法。
6.2.4 运行测试
测试类非常简单，调用被代理Bean跟调用普通Bean完全一样，Spring AOP将为目标对象创建AOP代理，具体测试代码如下：
java代码：
package cn.javass.spring.chapter6; 
import org.junit.Test; 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
import cn.javass.spring.chapter6.service.IHelloWorldService; 
import cn.javass.spring.chapter6.service.IPayService; 
public class AopTest { 
 @Test 
 public void testHelloworld() { 
 ApplicationContext ctx = new ClassPathXmlApplicationContext("chapter6/helloworld.xml"); 
 IHelloWorldService helloworldService = 
 ctx.getBean("helloWorldService", IHelloWorldService.class); 
 helloworldService.sayHello(); 
 } 
}
该测试将输出如下如下内容：
java代码：
===========before advice 
============Hello World! 
===========after finally advice
从输出我们可以看出：前置通知在切入点选择的连接点（方法）之前允许，而后置通知将在连接点（方法）之后执行，具体生成AOP代理及执行过程如图6-4所示。

图6-4 Spring AOP框架生成AOP代理过程
本系列：

跟我学 Spring 3（1）： Spring 概述
跟我学 Spring 3（2.1）：IoC 基础 
跟我学Spring3（2.2）：IoC容器基本原理
跟我学Spring3（2.3）：IoC容器基本原理
跟我学Spring3（3.1）：DI的配置使用
跟我学Spring3（3.2）：DI之循环依赖
跟我学Spring3（3.3）：更多的DI知识
跟我学Spring3（3.4）：DI之Bean的作用域
跟我学Spring3（4.1）：资源之基础知识
跟我学Spring3（4.2）：内置Resources实现
跟我学Spring3（4.3）：访问Resource
跟我学Spring3（4.4）：Resource通配符路径
跟我学Spring3（5.1 & 5.2）：Spring表达式语言之概述和SpEL基础
跟我学Spring3（5.3）：Spring 表达式语言之 SpEL 语法
跟我学Spring3（5.4）：在Bean定义中使用EL—跟我学spring3
跟我学Spring3（6.1）：AOP的HelloWorld



</td></tr><tr><td>http://www.importnew.com/21904.html</td><td>编程思想之多线程与多进程系列（中）</td><td>
原文出处： luoweifu
《编程思想之多线程与多进程(1)》一文详细讲述了线程、进程的关系及在操作系统中的表现，这是多线程学习必须了解的基础。本文将接着讲一下线程优先级和线程安全。

线程优先级
现在主流操作系统(如Windows、Linux、Mac OS X)的任务调度除了具有前面提到的时间片轮转的特点外，还有优先级调度(Priority Schedule)的特点。优先级调度决定了线程按照什么顺序轮流执行，在具有优先级调度的系统中，线程拥有各自的线程优先级(Thread Priority)。具有高优先级的线程会更早地执行，而低优先级的线程通常要等没有更高优先级的可执行线程时才会被执行。
线程的优先级可以由用户手动设置，此外系统也会根据不同情形调整优先级。通常情况下，频繁地进入等待状态(进入等待状态会放弃之前仍可占用的时间份额)的线程(如IO线程)，比频繁进行大量计算以至于每次都把所有时间片全部用尽的线程更受操作系统的欢迎。因为频繁进入等待的线程只会占用很少的时间，这样操作系统可以处理更多的任务。我们把频繁等待的线程称之为IO密集型线程(IO Bound Thread)，而把很少等待的线程称之为CPU密集型线程(CPU Bound Thread)。IO密集型线程总是比CPU密集型线程更容易得到优先级的提升。
线程饿死:
在优先级调度下，容易出现一种线程饿死的现象。一个线程饿死是说它的优先级较低，在它执行之前总是有比它优先级更高的线程等待执行，因此这个低优先级的线程始终得不到执行。当CPU密集型的线程优先级较高时，其它低优先级的线程就很可能出现饿死的情况；当IO密集型线程优先级较高时，其它线程相对不容易造成饿死的善，因为IO线程有大量的等待时间。为了避免线程饿死，调度系统通常会逐步提升那些等待了很久而得不到执行的线程的优先级。这样，一个线程只要它等待了足够长的时间，其优先级总会被提升到可以让它执行的程度，也就是说这种情况下线程始终会得到执行，只是时间的问题。
在优先级调度环境下，线程优先级的改变有三种方式：
1. 用户指定优先级；
2. 根据进入等待状态的频繁程度提升或降低优先级(由操作系统完成)；
3. 长时间得不到执行而被提升优先级。

线程安全与锁
在多个线程并发执行访问同一个数据时，如果不采取相应的措施，将会是非常危险的。假设你在工行有一个银行账户，两张银联卡(自己手里一张，女朋友手里一张)，里面有100万。假设取钱就两个过程：1.检查账户余额，2.取出现金(如果要取出的金额 > 账户余额，则取现成功，否则取现失败)。有一天你要买房想把钱取出来，而此时你女朋友也想买一辆车(假设你们事先没有商量)。两个人都在取钱，你在A号ATM机取100万，女朋友在B号ATM机取80万。这时A号ATM检查账户余额发现有100万，可以取出；而与此同时，同一时刻B号ATM也在检查账户余额发现有100万，可以取出；这样，A、B都把钱取出来了。
100万的存款取出180万，银行就亏大发了(当然你就笑呵呵了……)！这就是线程并发的不安全性。为避免这种情况发生，我们要将多个线程对同一数据的访问同步，确保线程安全。
所谓同步(synchronization)就是指一个线程访问数据时，其它线程不得对同一个数据进行访问，即同一时刻只能有一个线程访问该数据，当这一线程访问结束时其它线程才能对这它进行访问。同步最常见的方式就是使用锁(Lock)，也称为线程锁。锁是一种非强制机制，每一个线程在访问数据或资源之前，首先试图获取(Acquire)锁，并在访问结束之后释放(Release)锁。在锁被占用时试图获取锁，线程会进入等待状态，直到锁被释放再次变为可用。
二元信号量
二元信号量(Binary Semaphore)是一种最简单的锁，它有两种状态：占用和非占用。它适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量锁的线程会获得该锁，并将二元信号量锁置为占用状态，之后其它试图获取该二元信号量的线程会进入等待状态，直到该锁被释放。
信号量
多元信号量允许多个线程访问同一个资源，多元信号量简称信号量(Semaphore)，对于允许多个线程并发访问的资源，这是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。线程访问资源时首先获取信号量锁，进行如下操作：
1. 将信号量的值减1；
2. 如果信号量的值小于0，则进入等待状态，否则继续执行；
访问资源结束之后，线程释放信号量锁，进行如下操作：
1. 将信号量的值加1；
2. 如果信号量的值小于1(等于0)，唤醒一个等待中的线程；
互斥量
互斥量(Mutex)和二元信号量类似，资源仅允许一个线程访问。与二元信号量不同的是，信号量在整个系统中可以被任意线程获取和释放，也就是说，同一个信号量可以由一个线程获取而由另一线程释放。而互斥量则要求哪个线程获取了该互斥量锁就由哪个线程释放，其它线程越俎代庖释放互斥量是无效的。
临界区
临界区(Critical Section)是一种比互斥量更加严格的同步手段。互斥量和信号量在系统的任何进程都是可见的，也就是说一个进程创建了一个互斥量或信号量，另一进程试图获取该锁是合法的。而临界区的作用范围仅限于本进程，其它的进程无法获取该锁。除此之处，临界区与互斥量的性质相同。
读写锁
读写锁(Read-Write Lock)允许多个线程同时对同一个数据进行读操作，而只允许一个线程进行写操作。这是因为读操作不会改变数据的内容，是安全的；而写操作会改变数据的内容，是不安全的。对同一个读写锁，有两种获取方式：共享的(Shared)和独占的(Exclusive)。当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置为对应的状态；如果锁处于共享状态，其它线程以共享方式获取该锁，仍然能成功，此时该锁分配给了多个线程；如果其它线程试图如独占的方式获取处于共享状态的锁，它必须等待所有线程释放该锁；处于独占状态的锁阻止任何线程获取该锁，不论它们以何种方式。获取读写锁的方式总结如下：



读写锁的状态
以共享方式获取
以独占方式获取




自由
成功
成功


共享
成功
等待


独占
等待
等待



表 1 ：获取读写锁的方式


</td></tr><tr><td>http://www.importnew.com/21919.html</td><td>Java 9 将推迟到2017年7月发布</td><td>
原文出处： darkflame

本来以为在明年3月可以尝鲜的Java 9却要延迟了，据外媒报道，甲骨文宣布原定于2017年3月推出的Java 9将再延至2017年7月发布，主要原因是Java 9内置的模组化架构Jigsaw需要更长的时间来开发。

甲骨文Java平台的架构师Mark Reinhold在OpenJDK的邮件列表中提到了这个新的发布日期
Despite this progress, at this point it’s clear that Jigsaw needs more time. We recently received critical feedback that motivated a redesign of the module system’s package-export feature [5], without which we’d have failed to achieve one of our main goals. There are, beyond that, still many open design issues [6], which will take time to work through. Looking at the release as a whole, the number of open bugs that are new in JDK 9 is quite a bit larger than it was at this point in JDK 8. The maintainers of many popular projects are now actively testing against the JDK 9 EA builds [7], but we’d like to see even more in order to be confident that potential issues have been found and reported. For these reasons I hereby propose a four-month extension of the JDK 9 schedule, moving the General Availability (GA) milestone to July 2017.
Mark Reinhold称，由于收到使用者反馈，需要重新设计模组化架构Jigsaw中的Package-Export功能，更重要的是Java 9中还存在大量安全漏洞和Bug需要修复。
据悉，模组化架构Jigsaw将成为Java 9的核心功能，甲骨文也证实将会在Java9中新增新命令行工具Jshell、支持HTTP/2与新增多项API等。另外于今年1月推出的JDK9早期试用版不再支持Java浏览器外挂。
转自：太平洋新闻 以及 http://www.pixelstech.net/article/1474909477-Java-9-release-is-delayed-again


相关链接

Java 的详细介绍：请点这里
Java 的下载地址：请点这里




</td></tr><tr><td>http://www.importnew.com/21544.html</td><td>在 JDK 9 中更简洁使用 try-with-resources 语句</td><td>
原文出处： waylau
原本同步至 http://www.waylau.com/concise-try-with-resources-jdk9/
本文详细介绍了自 JDK 7 引入的 try-with-resources 语句的原理和用法，以及介绍了 JDK 9 对 try-with-resources 的改进，使得用户可以更加方便、简洁的使用 try-with-resources 语句。
在 JDK 7 之前，资源需要手动关闭。
例如下面一个很常见的文件操作的例子：
Charset charset = Charset.forName("US-ASCII");
String s = ...;
BufferedWriter writer = null;
try {
    writer = Files.newBufferedWriter(file, charset);
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format("IOException: %s%n", x);
} finally {
    if (writer != null) writer.close();
}
在 JDK 7 之前，你一定要牢记在 finally 中执行 close 以释放资源
JDK 7 中的 try-with-resources 介绍
try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。
例如，我们自定义一个资源类
public class Demo {    
    public static void main(String[] args) {
        try(Resource res = new Resource()) {
            res.doSome();
        } catch(Exception ex) {
            ex.printStackTrace();
        }
    }
}

class Resource implements AutoCloseable {
    void doSome() {
        System.out.println("do something");
    }
    @Override
    public void close() throws Exception {
        System.out.println("resource is closed");
    }
}
执行输出如下：
do something
resource is closed
可以看到，资源终止被自动关闭了。
再来看一个例子，是同时关闭多个资源的情况：
public class Main2 {    
    public static void main(String[] args) {
        try(ResourceSome some = new ResourceSome();
             ResourceOther other = new ResourceOther()) {
            some.doSome();
            other.doOther();
        } catch(Exception ex) {
            ex.printStackTrace();
        }
    }
}

class ResourceSome implements AutoCloseable {
    void doSome() {
        System.out.println("do something");
    }
    @Override
    public void close() throws Exception {
        System.out.println("some resource is closed");
    }
}

class ResourceOther implements AutoCloseable {
    void doOther() {
        System.out.println("do other things");
    }
    @Override
    public void close() throws Exception {
        System.out.println("other resource is closed");
    }
}
最终输出为：
do something
do other things
other resource is closed
some resource is closed
在 try 语句中越是最后使用的资源，越是最早被关闭。
try-with-resources 在 JDK 9 中的改进
作为 Milling Project Coin 的一部分, try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。
例如,给定资源的声明
// A final resource
final Resource resource1 = new Resource("resource1");
// An effectively final resource
Resource resource2 = new Resource("resource2");
老方法编写代码来管理这些资源是类似的:
// Original try-with-resources statement from JDK 7 or 8
try (Resource r1 = resource1;
     Resource r2 = resource2) {
    // Use of resource1 and resource 2 through r1 and r2.
}
而新方法可以是
// New and improved try-with-resources statement in JDK 9
try (resource1;
     resource2) {
    // Use of resource1 and resource 2.
}
看上去简洁很多吧。对 Java 未来的发展信心满满。
愿意尝试 JDK 9 这种新语言特性的可以下载使用 JDK 9 快照。Enjoy!
源码
本章例子的源码，可以在 https://github.com/waylau/essential-java 中com.waylau.essentialjava.exception.trywithresources 包下找到。
参考

更多内容可移步至笔者所著开源书《Java 编程要点》
https://blogs.oracle.com/darcy/entry/concise_twr_jdk9
http://docs.oracle.com/javase/8/docs/technotes/guides/language/try-with-resources.html



</td></tr><tr><td>http://www.importnew.com/22096.html</td><td>【闲说】性能测试</td><td>
原文出处： liuinsect
背景：
本次性能测试的目的是测试使用公司内部RPC框架开发的一套接口的性能，目的是准确的拿到接口的性能指标，当然，我也想换个角度去看待代码，比如，从性能或者对操作系统友好的角度，首先略过1万字的环境搭建过程，其实，性能测试是件非常考验细心程度的活，需要你对整个组网环境，调用关系,业务逻辑非常清晰，能正确识别出压力机，应用服务器，数据库服务器，缓存服务器各自的职责，并在可能的情况下压榨其性能极限，以及清楚明白可能对其性能造成影响的命令和操作（比如jvm启动参数中，大部分日志打印相关参数，关闭即时编译，调整GC分带的大小和比例等等）。
其次，还需要你能清楚本次测试程序的核心流程，业务逻辑，尽可能的将一些非核心的组件可能造成的影响去除掉，比如，本次测试的是RPC接口的性能和业务处理的效率，而相应涉及到的分布式缓存，数据库，则不是本次测试的重点，因此，组网时，应该尽可能将分布式缓存，数据库等机器与应用服务器放在同一个局域网网段内甚至同一台机器上，保证不会因为他们的表现而直接影响测试目标测试结果。总之，Mock掉一切非核心，不相关的因素。
测试工具/命令
因为是对RPC接口做测试（而非HTTP接口），使用loadRunner等测试工具无法满足要求，所以在测试工具的选择上，使用了jmeter。这是一款100%java实现的性能测试工具，使用方式是，继承他的AbstractJavaSamplerClient抽象类，在其runTest方法中编写测试用例即可在Jmeter的客户端中发现测试jar包，从而配置线程数后开始性能测试。具体使用请google之。
在压力机上部署好jmeter后，多线程开始执行测试用例，用例开始向应用服务器发送调用请求。这个时候设置的并发数应该尽量让压力机的CPU达到一个较高的值，比如 70%左右，jemeter提供了预热功能，必要时候可以使用预热功能将压力慢慢加大。
下面，我们借这次性能测试的机会介绍几个很好用的命令，启动后可以先到应用服务器上使用top命令，观察其CPU利用率，按数字键1，详细查看每个CPU的利用率。 理想情况，这个时候应该可以看到一定的压力。
也可以使用 vmstat命令，比如： vmstat 1  30 标示，每隔一秒打印一次统计信息，统计30秒。
打印结果类似：
     
通常主要关注r 和b 分别代表运行队列的数量和阻塞个数。理想情况应该是r比较多，b没有。
具体vmstat命令的结束可以看:http://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html
关注完CPU，还可以使用iostat命令 查看IO的情况，命令格式类似vmstat， iostat 1 30 表示同样的意思:每秒打印一次统计信息，打印30次后退出。
这里使用iostat -dx 1   每隔一秒打印一次磁盘的详细信息  具体可以参看这里：http://www.cnblogs.com/peida/archive/2012/12/28/2837345.html
   
可以看到io并不频繁。都是在很低 的水平上，因此IO应该不是此次性能测试的瓶颈所在。
看完vmstat,iostat,如果都不是处在很高的水平，下一个应该优先看网络，是的，对于linux还有一个netstat，使用方式与前两种不同，但是功能同样强大，可以列出应用服务器上所有tcp连接的详细信息。通常情况，可以观察下应用服务器上的TCP连接数，连接状态是否正常等来判断应用是否运行正常。
很好用的工具，动手输一下，你就会知道它的功能了。
测试目的
一般测试的目的有两个：
          1. 是获取接口的性能，常用TPS，延迟，QPS等衡量。
          2. 是通过性能测试，找出性能瓶颈，定位并优化它。

     因此，性能测试必须要满足的一个原则是，要么把压力机跑满，要么让应用服务器的某项指标跑满，之所以说某项指标，是因为，根据应用的不同，例如：CPU密集型应用，IO密集型应用，相应的，性嫩测试的时候应该尽量让CPU利用率或者IO利用率达到一个较高的水平。

     如果有一项指标没有达标，那性能瓶颈的定位过程就来了。

瓶颈定位
要定位瓶颈，首先需要知道应用服务器的哪项指标没有达到预期，是CPU利用率还是IO利用率或是都不高，这可以通过以上介绍的三个stat工具观察出来，如果没有看到哪项值比较高，至少也可以得到“都不高”的结论，而都不高的时候，或许意味着你的应用程序不像你想象的那么高效，一定，一定，在某个点上正在激烈的竞争者或者阻塞。程序会平白无故效率低下！
当然除了通过利用率，可以看到CPU或者IO的忙闲程度，有时我们还需要知道具体的数字，比如，哪种IO才算繁忙?
举个例子，这次性能测试时我使用了一个工具：ifstat，它并非系统自带的工具，需要手动安装，安装过程非常简单，自行google即可。
安装完毕后，将ifsta命令加入到path变量中，即可在全局使用ifstat命令，使用后的效果大致是这样：
     
eth0 代表了操作系统的第一张网卡。从这里可以看到此时这张网卡的读入速率是15M,出口是8M左右，而这张网卡的速率为：
   
也就是1000Mbit/s ,因为8B10B编码的关系，换算后理论的带宽为100M/S，100:15 利用率为15%，这个时候我们才可以说IO的利用率不高。IO不算繁忙。
同样的，有时会出现一种情况：CPU，网络/磁盘IO都不高，同样TPS也不高，这个时候可以从程序入手，分析下是否是程序执行缓慢的原因，原因大致有这么几种：
1. 有代码在串行的某件事,比如打日志（这次我就遇到了因为我使用自己写的工具监控方法执行时间的关系，在性能测试时有大量打印日志和计算工作 ，导致应用程序TPS非常低，拿掉工具后TPS才恢复到一个正常的水平，当然，这就不是说我的工具就不好用（笑） ，有兴趣的可以看下工具的介绍，总的来说还是很好用的，工具地址： https://github.com/liuinsect/Profiler）。
2. 多线程竞争，比如，多线程环境下，锁的竞争，对象监视器的竞争，数据库，分布式缓存连接的竞争（如果使用连接池的话）等。
3. 过于冗长，复杂方法的执行，虽然JIT可以执行一定程度上的优化，但是，糟糕代码无下限，要想写得烂，总是可以的。
4. 所依赖的系统慢，比如，数据库，分布式缓存慢（当然，他们的慢有更多种可能，有时候甚至需要找到他们慢的原因，并mock掉）。
这个时候就要借助visual vm等工具了。
因为很多时候我们是想在本地，去连接远程服务器上的JVM，这就涉及到了远程连接JVM的问题,可以这么做：
1.首先必须在远程机器上面启动jstatd这个后台进程。它位于JDK安装路径的bin目录里面。配置java安全访问，在jstatd所在的目录的下新建文件jstatd.all.policy,在我的机器上是/usr/java/jdk1.7.0_05/bin
grant codebase “file:${java.home}/../lib/tools.jar” {
permission java.security.AllPermission;
};
注意结尾还有一个分号。
2.然后用如下命令启动jstatd：
jstatd -J-Djava.security.policy=jstatd.all.policy
正常启动没有任何输出。默认打开端口是1099，也可以通过-p 参数设置端口。
3. 在本地打开 visual vm ，输入远程服务器的IP后，即可连接了。
当然，因为只是启动了jstatd，通过visual是不能使用线程监控，CPU监控的，如果需要用到这些功能的话，还需要使用JMX去远程连接tomcat 。方法在这里：http://www.oschina.net/question/162973_105064
通过visual vm 已经可以观察到GC的情况，运行的线程数，是Block，Running 等等情况了，如果应用程序竞争激烈，应该会看到线程运行条上有一段一段的红色区域，代表线程正在被频繁阻塞，再想深入，可用通过visual vm 将线程情况dump下来（当然，也可以在应用服务器上使用jstack -m <pid>），查看线程都被哪些对象阻塞，线程的调用栈是什么样子的， 从而定位到，应用程序中哪段代码有频繁竞争，为什么竞争，是否可以优化等。
当然，除了使用visual vm 还可以使用linux上的另外一个工具 perf ,他是linux 自带的性能分析工具。可以通过它看到系统执行的性能情况，功能实在强大，比如：
1. 列出L1,L2,L3 Cache的命中率（需要硬件支持，这次我们性能测试的机器不支持它）
2. 列出系统/进程的性能统计信息 命令： perf top -p pid
3. 分析程序的整体性能 perf stat
等等， 具体可以参考这里： http://iamzhongyong.iteye.com/blog/1908118
关于perf，这次还有一个小小的故事，在测试接口的某个方法时，使用perf观察到JVM的反射相关的方法耗时开销非常高，这才想起来反射相关的代码没有对反射的结果做缓存，因此果断回去加上缓存后，看到前面的方法在perf的列表中消失，这才放下心。
总结：
通过以上介绍的性能测试的思路和工具，我们基本上可以完成一次性能测试以及部分问题的性能定位，但是往往性能问题总是隐藏得很深的，并且受各种条件的影响，比如，各个环节的配置参数，网络情况，机器情况，性能测试的工具等等，所以，性能测试的结果往往不能脱离某个环境单独比较，不同的配置，环境，应用的性能都会呈现出不同的结果，出现问题时，也需要我们从前到后，从上到下仔细分析每一个流程的执行情况，逐步通过工具协助定位，才能最终找到瓶颈。总之，性能测试是一门考验耐心，细心，知识广度， 深度的活，每次遇到问题多问几个为什么，多做几次分析和验证，并尝试解决，优化它，一定会让你对系统有更多不一样的认识。


</td></tr><tr><td>http://www.importnew.com/21556.html</td><td>Java 编程要点之 I/O 流详解</td><td>
原文出处： waylau
原文同步至：http://www.waylau.com/essential-java-io-streams/
本文详细介绍了 Java I/O 流的基础用法和原理。
字节流(Byte Streams)
字节流处理原始的二进制数据 I/O。输入输出的是8位字节，相关的类为 InputStream 和 OutputStream.
字节流的类有许多。为了演示字节流的工作，我们将重点放在文件 I/O字节流 FileInputStream 和FileOutputStream 上。其他种类的字节流用法类似，主要区别在于它们构造的方式，大家可以举一反三。
用法
下面一例子 CopyBytes， 从 xanadu.txt 文件复制到 outagain.txt，每次只复制一个字节：
public class CopyBytes {
    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream("resources/xanadu.txt");
            out = new FileOutputStream("resources/outagain.txt");
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
}
CopyBytes 花费其大部分时间在简单的循环里面，从输入流每次读取一个字节到输出流，如图所示：

记得始终关闭流
不再需要一个流记得要关闭它，这点很重要。所以，CopyBytes 使用 finally 块来保证即使发生错误两个流还是能被关闭。这种做法有助于避免严重的资源泄漏。
一个可能的错误是，CopyBytes 无法打开一个或两个文件。当发生这种情况，对应解决方案是判断该文件的流是否是其初始 null 值。这就是为什么 CopyBytes 可以确保每个流变量在调用前都包含了一个对象的引用。
何时不使用字节流
CopyBytes 似乎是一个正常的程序，但它实际上代表了一种低级别的 I/O，你应该避免。因为 xanadu.txt 包含字符数据时，最好的方法是使用字符流，下文会有讨论。字节流应只用于最原始的 I/O。所有其他流类型是建立在字节流之上的。
字符流(Character Streams)
字符流处理字符数据的 I/O，自动处理与本地字符集转化。
Java 平台存储字符值使用 Unicode 约定。字符流 I/O 会自动将这个内部格式与本地字符集进行转换。在西方的语言环境中，本地字符集通常是 ASCII 的8位超集。
对于大多数应用，字符流的 I/O 不会比 字节流 I/O操作复杂。输入和输出流的类与本地字符集进行自动转换。使用字符的程序来代替字节流可以自动适应本地字符集，并可以准备国际化，而这完全不需要程序员额外的工作。
如果国际化不是一个优先事项，你可以简单地使用字符流类，而不必太注意字符集问题。以后，如果国际化成为当务之急，你的程序可以方便适应这种需求的扩展。见国际化获取更多信息。
用法
字符流类描述在 Reader 和 Writer。而对应文件 I/O ，在 FileReader 和 FileWriter，下面是一个 CopyCharacters 例子：
public class CopyCharacters {
    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        FileReader inputStream = null;
        FileWriter outputStream = null;

        try {
            inputStream = new FileReader("resources/xanadu.txt");
            outputStream = new FileWriter("resources/characteroutput.txt");

            int c;
            while ((c = inputStream.read()) != -1) {
                outputStream.write(c);
            }
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
            if (outputStream != null) {
                outputStream.close();
            }
        }
    }
}
CopyCharacters 与 CopyBytes 是非常相似的。最重要的区别在于 CopyCharacters 使用的 FileReader 和 FileWriter 用于输入输出，而 CopyBytes 使用 FileInputStream 和FileOutputStream 中的。请注意，这两个CopyBytes和CopyCharacters使用int变量来读取和写入；在 CopyCharacters，int 变量保存在其最后的16位字符值;在 CopyBytes，int 变量保存在其最后的8位字节的值。
字符流使用字节流
字符流往往是对字节流的“包装”。字符流使用字节流来执行物理I/O，同时字符流处理字符和字节之间的转换。例如，FileReader 使用 FileInputStream，而 FileWriter使用的是 FileOutputStream。
有两种通用的字节到字符的“桥梁”流：InputStreamReader 和 OutputStreamWriter。当没有预包装的字符流类时，使用它们来创建字符流。在 socket 章节中将展示该用法。
面向行的 I/O
字符 I/O 通常发生在较大的单位不是单个字符。一个常用的单位是行：用行结束符结尾。行结束符可以是回车/换行序列（“\r\n”），一个回车（“\r”），或一个换行符（“\n”）。支持所有可能的行结束符，程序可以读取任何广泛使用的操作系统创建的文本文件。
修改 CopyCharacters 来演示如使用面向行的 I/O。要做到这一点，我们必须使用两个类，BufferedReader 和PrintWriter 的。我们会在缓冲 I/O 和Formatting 章节更加深入地研究这些类。
该 CopyLines 示例调用 BufferedReader.readLine 和 PrintWriter.println 同时做一行的输入和输出。
public class CopyLines {
    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        BufferedReader inputStream = null;
        PrintWriter outputStream = null;

        try {
            inputStream = new BufferedReader(new FileReader("resources/xanadu.txt"));
            outputStream = new PrintWriter(new FileWriter("resources/characteroutput.txt"));

            String l;
            while ((l = inputStream.readLine()) != null) {
                outputStream.println(l);
            }
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
            if (outputStream != null) {
                outputStream.close();
            }
        }
    }
}
调用 readLine 按行返回文本行。CopyLines 使用 println 输出带有当前操作系统的行终止符的每一行。这可能与输入文件中不是使用相同的行终止符。
除字符和行之外，有许多方法来构造文本的输入和输出。欲了解更多信息，请参阅 Scanning 和 Formatting。
缓冲流（Buffered Streams）
缓冲流通过减少调用本地 API 的次数来优化的输入和输出。
目前为止，大多数时候我们到看到使用非缓冲 I/O 的例子。这意味着每次读或写请求是由基础 OS 直接处理。这可以使一个程序效率低得多，因为每个这样的请求通常引发磁盘访问，网络活动，或一些其它的操作，而这些是相对昂贵的。
为了减少这种开销，所以 Java 平台实现缓冲 I/O 流。缓冲输入流从被称为缓冲区（buffer）的存储器区域读出数据;仅当缓冲区是空时，本地输入 API 才被调用。同样，缓冲输出流，将数据写入到缓存区，只有当缓冲区已满才调用本机输出 API。
程序可以转换的非缓冲流为缓冲流，这里用非缓冲流对象传递给缓冲流类的构造器。
inputStream = new BufferedReader(new FileReader("xanadu.txt"));
outputStream = new BufferedWriter(new FileWriter("characteroutput.txt"));
用于包装非缓存流的缓冲流类有4个：BufferedInputStream 和 BufferedOutputStream 用于创建字节缓冲字节流,BufferedReader 和 BufferedWriter 用于创建字符缓冲字节流。
刷新缓冲流
刷新缓冲区是指在某个缓冲的关键点就可以将缓冲输出，而不必等待它填满。
一些缓冲输出类通过一个可选的构造函数参数支持 autoflush（自动刷新）。当自动刷新开启，某些关键事件会导致缓冲区被刷新。例如，自动刷新 PrintWriter 对象在每次调用 println 或者 format 时刷新缓冲区。查看 Formatting 了解更多关于这些的方法。
如果要手动刷新流，请调用其 flush 方法。flush 方法可以用于任何输出流，但对非缓冲流是没有效果的。
扫描（Scanning）和格式化（Formatting）
扫描和格式化允许程序读取和写入格式化的文本。
I/O 编程通常涉及对人类喜欢的整齐的格式化数据进行转换。为了帮助您与这些琐事，Java 平台提供了两个API。scanning API 使用分隔符模式将其输入分解为标记。formatting API 将数据重新组合成格式良好的，人类可读的形式。
扫描
将其输入分解为标记
默认情况下，Scanner 使用空格字符分隔标记。（空格字符包括空格，制表符和行终止符。为完整列表，请参阅 Character.isWhitespace）。示例 ScanXan 读取 xanadu.txt 的单个词语并打印他们：
public class ScanXan {
    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        Scanner s = null;

        try {
            s = new Scanner(new BufferedReader(new FileReader("resources/xanadu.txt")));

            while (s.hasNext()) {
                System.out.println(s.next());
            }
        } finally {
            if (s != null) {
                s.close();
            }
        }
    }
}
虽然 Scanner 不是流，但你仍然需要关闭它，以表明你与它的底层流执行完成。
调用 useDelimiter() ,指定一个正则表达式可以使用不同的标记分隔符。例如,假设您想要标记分隔符是一个逗号，后面可以跟空格。你会调用
s.useDelimiter(",\\s*");
转换成独立标记
该 ScanXan 示例是将所有的输入标记为简单的字符串值。Scanner 还支持所有的 Java 语言的基本类型（除 char），以及 BigInteger 和 BigDecimal 的。此外，数字值可以使用千位分隔符。因此，在一个美国的区域设置，Scanner 能正确地读出字符串“32,767”作为一个整数值。
这里要注意的是语言环境，因为千位分隔符和小数点符号是特定于语言环境。所以，下面的例子将无法正常在所有的语言环境中，如果我们没有指定 scanner 应该用在美国地区工作。可能你平时并不用关心，因为你输入的数据通常来自使用相同的语言环境。可以使用下面的语句来设置语言环境：
s.useLocale(Locale.US);
该 ScanSum 示例是将读取的 double 值列表进行相加：
public class ScanSum {
    /**
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        Scanner s = null;
        double sum = 0;

        try {
            s = new Scanner(new BufferedReader(new FileReader("resources/usnumbers.txt")));
            s.useLocale(Locale.US);

            while (s.hasNext()) {
                if (s.hasNextDouble()) {
                    sum += s.nextDouble();
                } else {
                    s.next();
                }
            }
        } finally {
            s.close();
        }

        System.out.println(sum);
    }
}
输出为:1032778.74159
格式化
实现格式化流对象要么是 字符流类的 PrintWriter 的实例，或为字节流类的 PrintStream 的实例。
注：对于 PrintStream 对象，你很可能只需要 System.out 和 System.err。 （请参阅命令行I/O）当你需要创建一个格式化的输出流，请实例化 PrintWriter，而不是 PrintStream。
像所有的字节和字符流对象一样，PrintStream 和 PrintWriter 的实例实现了一套标准的 write 方法用于简单的字节和字符输出。此外，PrintStream 和 PrintWriter 的执行同一套方法，将内部数据转换成格式化输出。提供了两个级别的格式：

print 和 println 在一个标准的方式里面格式化独立的值 。
format 用于格式化几乎任何数量的格式字符串值，且具有多种精确选择。

print 和 println 方法
调用 print 或 println 输出使用适当 toString 方法变换后的值的单一值。我们可以看到这 Root 例子：
public class Root {
    /**
     * @param args
     */
    public static void main(String[] args) {
            int i = 2;
        double r = Math.sqrt(i);

        System.out.print("The square root of ");
        System.out.print(i);
        System.out.print(" is ");
        System.out.print(r);
        System.out.println(".");

        i = 5;
        r = Math.sqrt(i);
        System.out.println("The square root of " + i + " is " + r + ".");
    }
}
输出为：
The square root of 2 is 1.4142135623730951.
The square root of 5 is 2.23606797749979.
在 i 和 r 变量格式化了两次：第一次在重载的 print 使用代码，第二次是由Java编译器转换码自动生成，它也利用了 toString。您可以用这种方式格式化任意值，但对于结果没有太多的控制权。
format 方法
该 format 方法用于格式化基于 format string（格式字符串） 多参。格式字符串包含嵌入了 format specifiers （格式说明)的静态文本;除非使用了格式说明，否则格式字符串输出不变。
格式字符串支持许多功能。在本教程中，我们只介绍一些基础知识。有关完整说明，请参阅 API 规范关于格式字符串语法。
Root2 示例在一个 format 调用里面设置两个值：
public class Root2 {
    /**
     * @param args
     */
    public static void main(String[] args) {
        int i = 2;
        double r = Math.sqrt(i);

        System.out.format("The square root of %d is %f.%n", i, r);
    }
}
输出为：The square root of 2 is 1.414214.
像本例中所使用的格式为：

d 格式化整数值为小数
f 格式化浮点值作为小数
n 输出特定于平台的行终止符。

这里有一些其他的转换格式：

x 格式化整数为十六进制值
s 格式化任何值作为字符串
tB 格式化整数作为一个语言环境特定的月份名称。

还有许多其他的转换。
注意：除了 %% 和 %n，其他格式符都要匹配参数，否则抛出异常。在 Java 编程语言中，\ n转义总是产生换行符（\u000A）。不要使用\ñ除非你特别想要一个换行符。为了针对本地平台得到正确的行分隔符，请使用％n。
除了用于转换，格式说明符可以包含若干附加的元素，进一步定制格式化输出。下面是一个 Format 例子，使用一切可能的一种元素。
public class Format {
    /**
     * @param args
     */
    public static void main(String[] args) {
         System.out.format("%f, %1$+020.10f %n", Math.PI);
    }
}
输出为：3.141593, +00000003.1415926536
附加元素都是可选的。下图显示了长格式符是如何分解成元素

元件必须出现在显示的顺序。从合适的工作，可选的元素是：

Precision(精确)。对于浮点值，这是格式化值的数学精度。对于 s 和其他一般的转换，这是格式化值的最大宽度;该值右截断，如果有必要的。
Width(宽度)。格式化值的最小宽度;如有必要，该值被填充。默认值是左用空格填充。
Flags(标志)指定附加格式设置选项。在 Format 示例中，+ 标志指定的数量应始终标志格式，以及0标志指定0是填充字符。其他的标志包括 – （垫右侧）和（与区域特定的千位分隔符格式号）。请注意，某些标志不能与某些其他标志或与某些转换使用。
Argument Index(参数索引)允许您指定的参数明确匹配。您还可以指定<到相同的参数作为前面的说明一致。这样的例子可以说：System.out.format（“％F，％<+ 020.10f％N”，Math.PI）;

命令行 I/O
命令行 I/O 描述了标准流（Standard Streams）和控制台（Console）对象。
Java 支持两种交互方式：标准流（Standard Streams）和通过控制台（Console）。
标准流
标准流是许多操作系统的一项功能。默认情况下，他们从键盘读取输入和写出到显示器。它们还支持对文件和程序之间的 I/O，但该功能是通过命令行解释器，而不是由程序控制。
Java平台支持三种标准流：标准输入（Standard Input, 通过 System.in 访问）、标准输出（Standard Output, 通过System.out 的访问）和标准错误（ Standard Error, 通过System.err的访问）。这些对象被自动定义，并不需要被打开。标准输出和标准错误都用于输出;错误输出允许用户转移经常性的输出到一个文件中，仍然能够读取错误消息。
您可能希望标准流是字符流，但是，由于历史的原因，他们是字节流。 System.out 和System.err 定义为PrintStream 的对象。虽然这在技术上是一个字节流，PrintStream 利用内部字符流对象来模拟多种字符流的功能。
相比之下，System.in 是一个没有字符流功能的字节流。若要想将标准的输入作为字符流，可以包装 System.in 在 InputStreamReader
InputStreamReader cin = new InputStreamReader(System.in);
Console (控制台)
更先进的替代标准流的是 Console 。这个单一，预定义的 Console 类型的对象，有大部分的标准流提供的功能，另外还有其他功能。Console 对于安全的密码输入特别有用。Console 对象还提供了真正的输入输出字符流，是通过 reader 和 writer 方法实现的。
若程序想使用 Console ，它必须尝试通过调用 System.console() 检索 Console 对象。如果 Console 对象存在，通过此方法将其返回。如果返回 NULL，则 Console 操作是不允许的，要么是因为操作系统不支持他们或者是因为程序本身是在非交互环境中启动的。
Console 对象支持通过读取密码的方法安全输入密码。该方法有助于在两个方面的安全。第一，它抑制回应，因此密码在用户的屏幕是不可见的。第二，readPassword 返回一个字符数组，而不是字符串，所以，密码可以被覆盖，只要它是不再需要就可以从存储器中删除。
Password 例子是一个展示了更改用户的密码原型程序。它演示了几种 Console 方法
public class Password {
    /**
     * @param args
     */
    public static void main(String[] args) {
        Console c = System.console();
        if (c == null) {
            System.err.println("No console.");
            System.exit(1);
        }

        String login = c.readLine("Enter your login: ");
        char [] oldPassword = c.readPassword("Enter your old password: ");

        if (verify(login, oldPassword)) {
            boolean noMatch;
            do {
                char [] newPassword1 = c.readPassword("Enter your new password: ");
                char [] newPassword2 = c.readPassword("Enter new password again: ");
                noMatch = ! Arrays.equals(newPassword1, newPassword2);
                if (noMatch) {
                    c.format("Passwords don't match. Try again.%n");
                } else {
                    change(login, newPassword1);
                    c.format("Password for %s changed.%n", login);
                }
                Arrays.fill(newPassword1, ' ');
                Arrays.fill(newPassword2, ' ');
            } while (noMatch);
        }

        Arrays.fill(oldPassword, ' ');
    }

    // Dummy change method.
    static boolean verify(String login, char[] password) {
        // This method always returns
        // true in this example.
        // Modify this method to verify
        // password according to your rules.
        return true;
    }

    // Dummy change method.
    static void change(String login, char[] password) {
        // Modify this method to change
        // password according to your rules.
    }
}
上面的流程是：

尝试检索 Console 对象。如果对象是不可用，中止。
调用 Console.readLine 提示并读取用户的登录名。
调用 Console.readPassword 提示并读取用户的现有密码。
调用 verify 确认该用户被授权可以改变密码。（在本例中，假设 verify 是总是返回true ）
重复下列步骤，直到用户输入的密码相同两次：

调用 Console.readPassword 两次提示和读一个新的密码。
如果用户输入的密码两次，调用 change 去改变它。 （同样，change 是一个虚拟的方法）
用空格覆盖这两个密码。


用空格覆盖旧的密码。

数据流（Data Streams）
Data Streams 处理原始数据类型和字符串值的二进制 I/O。
支持基本数据类型的值（(boolean, char, byte, short, int, long, float, 和 double）以及字符串值的二进制 I/O。所有数据流实现 DataInput 或 DataOutput 接口。本节重点介绍这些接口的广泛使用的实现，DataInputStream 和DataOutputStream 类。
DataStreams 例子展示了数据流通过写出的一组数据记录到文件，然后再次从文件中读取这些记录。每个记录包括涉及在发票上的项目，如下表中三个值：



记录中顺序
数据类型
数据描述
输出方法
输入方法
示例值




1
double
Item price
DataOutputStream.writeDouble
DataInputStream.readDouble
19.99


2
int
Unit count
DataOutputStream.writeInt
DataInputStream.readInt
12


3
String
Item description
DataOutputStream.writeUTF
DataInputStream.readUTF
“Java T-Shirt”



首先，定义了几个常量，数据文件的名称，以及数据。
static final String dataFile = "invoicedata";

static final double[] prices = { 19.99, 9.99, 15.99, 3.99, 4.99 };
static final int[] units = { 12, 8, 13, 29, 50 };
static final String[] descs = {
    "Java T-shirt",
    "Java Mug",
    "Duke Juggling Dolls",
    "Java Pin",
    "Java Key Chain"
};
DataStreams 打开一个输出流，提供一个缓冲的文件输出字节流：
out = new DataOutputStream(new BufferedOutputStream(
              new FileOutputStream(dataFile)))
DataStreams 写出记录并关闭输出流：
for (int i = 0; i < prices.length; i ++) {
    out.writeDouble(prices[i]);
    out.writeInt(units[i]);
    out.writeUTF(descs[i]);
}
该 writeUTF 方法写出以 UTF-8 改进形式的字符串值。
现在，DataStreams 读回数据。首先，它必须提供一个输入流，和变量来保存的输入数据。像 DataOutputStream 、DataInputStream 类，必须构造成一个字节流的包装器。
in = new DataInputStream(new
            BufferedInputStream(new FileInputStream(dataFile)));

double price;
int unit;
String desc;
double total = 0.0;
现在，DataStreams 可以读取流里面的每个记录，并在遇到它时将数据报告出来：
try {
    while (true) {
        price = in.readDouble();
        unit = in.readInt();
        desc = in.readUTF();
        System.out.format("You ordered %d" + " units of %s at $%.2f%n",
            unit, desc, price);
        total += unit * price;
    }
} catch (EOFException e) {
}
请注意，DataStreams 通过捕获 EOFException 检测文件结束的条件而不是测试无效的返回值。所有实现了 DataInput 的方法都使用 EOFException 类来代替返回值。
还要注意的是 DataStreams 中的各个 write 需要匹配对应相应的 read。它需要由程序员来保证。
DataStreams 使用了一个非常糟糕的编程技术：它使用浮点数来表示的货币价值。在一般情况下，浮点数是不好的精确数值。这对小数尤其糟糕，因为共同值（如 0.1），没有一个二进制的表示。
正确的类型用于货币值是 java.math.BigDecimal 的。不幸的是，BigDecimal 是一个对象的类型，因此它不能与数据流工作。然而，BigDecimal 将与对象流工作，而这部分内容将在下一节讲解。
对象流（Object Streams）
对象流处理对象的二进制 I/O。
正如数据流支持的是基本数据类型的 I/O，对象流支持的对象 I/O。大多数，但不是全部，标准类支持他们的对象的序列化，都需要实现 Serializable 接口。
对象流类包括 ObjectInputStream 和 ObjectOutputStream 的。这些类实现的 ObjectInput 与 ObjectOutput 的，这些都是 DataInput 和DataOutput 的子接口。这意味着，所有包含在数据流中的基本数据类型 I/O 方法也在对象流中实现了。这样一个对象流可以包含基本数据类型值和对象值的混合。该ObjectStreams 例子说明了这一点。ObjectStreams 创建与 DataStreams 相同的应用程序。首先，价格现在是 BigDecimal 对象，以更好地代表分数值。其次，Calendar 对象被写入到数据文件中，指示发票日期。
public class ObjectStreams {
    static final String dataFile = "invoicedata";

    static final BigDecimal[] prices = { 
        new BigDecimal("19.99"), 
        new BigDecimal("9.99"),
        new BigDecimal("15.99"),
        new BigDecimal("3.99"),
        new BigDecimal("4.99") };
    static final int[] units = { 12, 8, 13, 29, 50 };
    static final String[] descs = { "Java T-shirt",
            "Java Mug",
            "Duke Juggling Dolls",
            "Java Pin",
            "Java Key Chain" };

    public static void main(String[] args) 
        throws IOException, ClassNotFoundException {

        ObjectOutputStream out = null;
        try {
            out = new ObjectOutputStream(new
                    BufferedOutputStream(new FileOutputStream(dataFile)));

            out.writeObject(Calendar.getInstance());
            for (int i = 0; i < prices.length; i ++) {
                out.writeObject(prices[i]);
                out.writeInt(units[i]);
                out.writeUTF(descs[i]);
            }
        } finally {
            out.close();
        }

        ObjectInputStream in = null;
        try {
            in = new ObjectInputStream(new
                    BufferedInputStream(new FileInputStream(dataFile)));

            Calendar date = null;
            BigDecimal price;
            int unit;
            String desc;
            BigDecimal total = new BigDecimal(0);

            date = (Calendar) in.readObject();

            System.out.format ("On %tA, %<tB %<te, %<tY:%n", date);

            try {
                while (true) {
                    price = (BigDecimal) in.readObject();
                    unit = in.readInt();
                    desc = in.readUTF();
                    System.out.format("You ordered %d units of %s at $%.2f%n",
                            unit, desc, price);
                    total = total.add(price.multiply(new BigDecimal(unit)));
                }
            } catch (EOFException e) {}
            System.out.format("For a TOTAL of: $%.2f%n", total);
        } finally {
            in.close();
        }
    }
}
如果的 readObject() 不返回预期的对象类型，试图将它转换为正确的类型可能会抛出一个ClassNotFoundException。在这个简单的例子，这是不可能发生的，所以我们不要试图捕获异常。相反，我们通知编译器，我们已经意识到这个问题，添加 ClassNotFoundException 到主方法的 throws 子句中的。
复杂对象的 I/O
writeObject 和 readObject 方法简单易用，但它们包含了一些非常复杂的对象管理逻辑。这不像 Calendar 类，它只是封装了原始值。但许多对象包含其他对象的引用。如果 readObject 从流重构一个对象，它必须能够重建所有的原始对象所引用的对象。这些额外的对象可能有他们自己的引用，依此类推。在这种情况下，writeObject 遍历对象引用的整个网络，并将该网络中的所有对象写入流。因此，writeObject 单个调用可以导致大量的对象被写入流。
如下图所示，其中 writeObject 调用名为 a 的单个对象。这个对象包含对象的引用 b和 c，而 b 包含引用 d 和 e。调用 writeObject(a) 写入的不只是一个 a，还包括所有需要重新构成的这个网络中的其他4个对象。当通过 readObject 读回 a 时，其他四个对象也被读回，同时，所有的原始对象的引用被保留。

如果在同一个流的两个对象引用了同一个对象会发生什么？流只包含一个对象的一个拷贝，尽管它可以包含任何数量的对它的引用。因此，如果你明确地写一个对象到流两次，实际上只是写入了2此引用。例如，如果下面的代码写入一个对象 ob 两次到流：
Object ob = new Object();
out.writeObject(ob);
out.writeObject(ob);
每个 writeObject 都对应一个 readObject， 所以从流里面读回的代码如下：
Object ob1 = in.readObject();
Object ob2 = in.readObject();
ob1 和 ob2 都是相同对象的引用。
然而，如果一个单独的对象被写入到两个不同的数据流，它被有效地复用 – 一个程序从两个流读回的将是两个不同的对象。
源码
本章例子的源码，可以在 https://github.com/waylau/essential-java 中 com.waylau.essentialjava.io 包下找到。
参考

更多内容可移步至笔者所著开源书《Java 编程要点》



</td></tr></table></body></html>